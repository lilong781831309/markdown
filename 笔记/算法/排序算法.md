[TOC]



# 一、单词解释

 ```java
bubbleSort   冒泡排序
selectSort   选择排序
insertSort   插入排序
shellSort    希尔排序
mergeSort    归并排序
quickSort    快速排序
heapSort     堆排序
countSort    计数排序
bucketSort   桶排序
radixSort    基数排序
recursion    递归
nonrecursion 非递归
partition    分区
pivot        轴
 ```

# 二、通用方法
```java
public static void main(String[] args) {
    int[] arr = random(50000, 50000);
    print(arr);
    long start = System.currentTimeMillis();
        
    quickSort(arr);
        
    long end = System.currentTimeMillis();
    print(arr);
    System.out.println("sorted: " + isSorted(arr));
    System.out.println("cost: " + (end - start));
}
    
public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
    
private static int[] random(int range, int size) {
    int[] arr = new int[size];
    int len = arr.length;
    Random random = new Random();
    for (int i = 0; i < len; i++) {
        arr[i] = random.nextInt(range);
    }
    return arr;
}

private static void print(int[] arr) {
    int len = arr.length;
    for (int i = 0; i < len; i++) {
        if (i < len - 1) {
            System.out.print(arr[i] + ",");
        } else {
            System.out.println(arr[i]);
        }
    }
}

private static boolean isSorted(int[] arr) {
    int len = arr.length;
    for (int i = 0; i < len - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            return false;
        }
    }
    return true;
}
```
# 三、排序算法

## 1、冒泡排序

```java
public static void bubbleSort(int arr[]) {
    int len = arr.length, i, j;
    for (i = 0; i < len - 1; i++) {
        for (j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr, j, j + 1);
            }
        }
    }
}
```

## 2、选择排序
```java
public static void selectSort(int arr[]) {
    int len = arr.length, left, right, min, max, i;
    for (left = 0, right = len - 1; left < right; left++, right--) {
        min = left;
        max = right;
        for (i = left; i <= right; i++) {
            if (arr[i] < arr[min]) {
                min = i;
            }
            if (arr[i] > arr[max]) {
                max = i;
            }
        }
        if (min != left) {
            swap(arr, min, left);
        }
        if (max != right) {
            swap(arr, left == max ? min : max, right);
        }
    }
}
```

## 3、插入排序
```java
public static void insertSort(int arr[]) {
    insertSort(arr, 0, arr.length - 1);
}

public static void insertSort(int arr[], int low, int high) {
    int i, j, temp;
    for (i = low; i <= high; i++) {
        j = i;
        temp = arr[j];
        while (j > low && temp < arr[j - 1]) {
            arr[j] = arr[j - 1];
            j--;
        }
        arr[j] = temp;
    }
}
```

## 4、希尔排序
```java
public static void shellSort(int arr[]) {
    int len = arr.length, gap = len >> 1, i, j, temp;
    while (gap > 0) {
        for (i = gap; i < len; i++) {
            j = i;
            temp = arr[j];
            while (j >= gap && temp < arr[j - gap]) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = temp;
        }
        gap >>= 1;
    }
}
```

## 5、归并排序
```java
public static void mergeSort(int arr[]) {
    mergeSortRecursion(arr, 0, arr.length - 1, new int[arr.length]);
}

private static void mergeSortRecursion(int arr[], int low, int high, int[] temp) {
    if (low < high) {
        int mid = (low + high) >> 1;
        mergeSortRecursion(arr, low, mid, temp);
        mergeSortRecursion(arr, mid + 1, high, temp);
        merge(arr, low, mid, high, temp);
    }
}
    
private static void mergeSortNonRecursion(int arr[]) {
    int len = arr.length, low, k = 1;
    int[] temp = new int[len];
    while (k < len) {
        low = 0;
        while (low + k * 2 - 1 < len) {
            merge(arr, low, low + k - 1, low + k * 2 - 1, temp);
            low += k * 2;
        }
        if (low + k < len) {
            merge(arr, low, low + k - 1, len - 1, temp);
        }
        k <<= 1;
    }
}

private static void merge(int arr[], int low, int mid, int high, int[] temp) {
    if (low < high) {
        int i = low, j = mid + 1, k = 0;
        while (i <= mid && j <= high) {
            if (arr[i] < arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }
        while (i <= mid) {
            temp[k++] = arr[i++];
        }
        while (j <= high) {
            temp[k++] = arr[j++];
        }
        for (int t = 0; t < k; t++) {
            arr[t + low] = temp[t];
        }
    }
}
```

## 6、快速排序
```
    public static void quickSort(int[] arr) {
        quickSortRecursion(arr, 0, arr.length - 1);
    }

    private static void quickSortRecursion(int[] arr, int low, int high) {
        if (low < high) {
            int pivot = partition(arr, low, high);
            quickSortRecursion(arr, low, pivot - 1);
            quickSortRecursion(arr, pivot + 1, high);
        }
    }

    private static void quickSortNonRecursion(int[] arr) {
        Stack<Integer> stack = new Stack<>();
        stack.push(arr.length - 1);
        stack.push(0);

        int low, high;

        while (!stack.empty()) {
            low = stack.pop();
            high = stack.pop();

            if (low < high) {
                int pivot = partition(arr, low, high);

                stack.push(high);
                stack.push(pivot + 1);

                stack.push(pivot - 1);
                stack.push(low);
            }
        }
    }

    private static int partition(int[] arr, int low, int high) {
        if (low < high) {
            int i = low, j = high, temp = arr[i];
            while (i < j) {
                while (i < j && arr[j] >= temp) {
                    j--;
                }
                arr[i] = arr[j];
                while (i < j && arr[i] <= temp) {
                    i++;
                }
                arr[j] = arr[i];
            }
            arr[i] = temp;
            return i;
        }
        return low;
    }
```

## 7、堆排序
```java
public static void heapSort(int[] arr) {
    int last = arr.length - 1;
    int p = (last - 1) >> 1;
    while (p >= 0) {
        shiftDown(arr, p--, last);
    }
    while (last > 0) {
        swap(arr, 0, last);
        shiftDown(arr, 0, --last);
    }
}

public static void shiftDown(int[] arr, int p, int last) {
    int k = (p << 1) + 1, temp = arr[p];
    while (k <= last) {
        if (k < last && arr[k] < arr[k + 1]) {
            k++;
        }
        if (arr[k] > temp) {
            arr[p] = arr[k];
        } else {
            break;
        }
        p = k;
        k = (p << 1) + 1;
    }
    arr[p] = temp;
}
```

## 8、计数排序
```java
public static void countSort(int[] arr) {
    int len = arr.length, min = arr[0], max = arr[0];
    int i;
    for (i = 1; i < len; i++) {
        if (arr[i] < min) {
            min = arr[i];
        }
        if (arr[i] > max) {
            max = arr[i];
        }
    }

    int[] count = new int[max - min + 1];
    for (i = 0; i < len; i++) {
        count[arr[i] - min]++;
    }

    for (i = 1; i < count.length; i++) {
        count[i] += count[i - 1];
    }

    int[] temp = new int[len];
    for (i = len - 1; i >= 0; i--) {
        temp[--count[arr[i] - min]] = arr[i];
    }

    for (i = 0; i < len; i++) {
        arr[i] = temp[i];
    }
}
```

## 9、桶排序
```java
public static void bucketSort(int[] arr) {

}
```

## 10、基数排序
```java
public static void radixSort(int[] arr) {

}
```