[TOC]



# 一、基础题

## 4、switch支持的类型

```java
在 Java 语言规范里中，有说明 switch 支持的类型有：char、byte、short、int、Character、Byte、Short、Integer、String、enum。
为什么不能支持long呢？

原因就是 switch 对应的 JVM 字节码 lookupswitch、tableswitch 指令只支持 int 类型。

1.1 byte、char、short
byte、char、short 类型在编译期默认提升为 int，并使用 int 类型的字节码指令。所以对这些类型使用 switch，其实跟 int 类型是一样的。

1.2 enum
enum最终也是转换为enum的int序号来适应switch的。

1.3 String
switch 支持 String 其实就是语法糖。编译器会根据字符串的 hashCode 来处理。


如：

String a = "aa";
switch (a) {
  case "aa":
    System.out.println("111");
    break;
  case "AaAa":
    System.out.println("222");
    break;
  case "AaBB":
    System.out.println("333");
    break;
}
反编译后：

String var1 = "aa";
byte var3 = -1;
switch(var1.hashCode()) { // 第一个switch，根据hashCode计算第二个switch内的位置
  case 3104:
    if (var1.equals("aa")) {
      var3 = 0;
    }
    break;
  case 2031744:
    if (var1.equals("AaBB")) {
      var3 = 2;
    } else if (var1.equals("AaAa")) {
      var3 = 1;
    }
}

switch(var3) { // 第二个switch，执行原switch的逻辑
  case 0:
    System.out.println("111");
    break;
  case 1:
    System.out.println("222");
    break;
  case 2:
    System.out.println("333");
}
可以发现，会先根据 hashCode 找出原始 switch 内的位置，再执行原代码逻辑。

switch 内有的 case 不写 break 等复杂情况，如果想直接根据 hashCode + equals 来只生成一个 switch，编译器就需要考虑各种情况。为了减少编译器的工作, 目前编译器只做位置映射，第二部分直接按原 switch 来生成了。
```
## 12、运行结果
```java
public static void main(String[] args) {
    char x = 'x';
    int i = 10;
    System.out.println(true? x : i);
    System.out.println(true? 'x' : 10);
}
```
```java
答案：
	120
    x
    
    三元操作符类型的转换规则：
    1.若两个操作数不可转换，则不做转换，返回值为Object类型。
    2.若两个操作数是明确类型的表达式（比如变量），则按照正常的二进制数字来转换，int类型转换为long类型，long类型转换为float类型等。
    3.若两个操作数中有一个是数字S，另外一个是表达式，且其类型标示为T，那么，若数字S在T的范围内，则转换为T类型；若S超出了T类型的范围，则T转换为S类型。
    4.若两个操作数都是直接量数字（Literal），则返回值类型为范围较大者。
```
## 16、运行结果
```java
public static void main(String[] args) {
    int i = 10;
    while (i > 0) {
        i = i + 1;
        if (i == 10) {
            break;
        }
    }
    System.out.println("i=" + i);
}
```
```java
答案:
    -2147483648
    Integer.MIN_VALUE
    
说明：i 一直加到Integer.MAX_VALUE 后溢出
    Integer.MAX_VALUE = 0b0111_1111_1111_1111_1111_1111_1111_1111
    
    执行 +1 后
                      = 0b1000_0000_0000_0000_0000_0000_0000_0000
                      = Integer.MIN_VALUE
                      = -2147483648
```
## 19、运行结果
```java
public static void main(String[] args) {
    int i = 0;
    change(i);
    i = i++;
    System.out.println("i = " + i);
} 
public static void change(int i){
    i++;
}

main  中的i 存在main  方法栈帧中的局部变量
change中的i 存在change方法栈帧中的局部变量
相互不影响
```
```java
Compiled from "Test.java"
public class org.xinhua.io.Test {
  public org.xinhua.io.Test();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: iconst_0
       1: istore_1
       2: iload_1
       3: invokestatic  #2                  // Method change:(I)V
       6: iload_1
       7: iinc          1, 1
      10: istore_1
      11: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
      14: new           #4                  // class java/lang/StringBuilder
      17: dup
      18: invokespecial #5                  // Method java/lang/StringBuilder."<init>":()V
      21: ldc           #6                  // String i =
      23: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;
      26: iload_1
      27: invokevirtual #8                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;
      30: invokevirtual #9                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;
      33: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      36: return

  public static void change(int);
    Code:
       0: iinc          0, 1
       3: return
}
```
运行步骤：
字节码 | 操作| 栈顶| 局部变量i
---|---|---|---
0: iconst_0  | 常量0入操作数栈| 0| 0
1: istore_1  |操作数栈弹出栈顶元素,存入局部变量i |     空  |     0
2: iload_1  | 局部变量i存入 操作数栈| 0| 0
3: invokestatic  | 执行 change 方法| 0| 0
6: iload_1 | 局部变量i存入 操作数栈| 0| 0
7: iinc  1, 1   | 局部变量i自增| 0| 1
10: istore_1  | 操作数栈弹出栈顶元素,存入局部变量i|空| 0
11: getstatic  | 打印|空| 0

## 21、运行结果
```java
public static void main(String[] args) {
    Integer i1 = 128;
	Integer i2 = 128;
	int i3 = 128;
	int i4 = 128;
	System.out.println(i1 == i2);
	System.out.println(i3 == i4);
	System.out.println(i1 == i3);
}
```
```java
答案：
    false
    true
    true
```
```java
IntegerCache代码片段:
    
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];

    static {
        // high value may be configured by property
       int h = 127;
       String integerCacheHighPropValue =
            sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
       if (integerCacheHighPropValue != null) {
            try {
                int i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
            } catch( NumberFormatException nfe) {
                // If the property cannot be parsed into an int, ignore it.
            }
        }
        high = h;

        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k < cache.length; k++)
            cache[k] = new Integer(j++);

        // range [-128, 127] must be interned (JLS7 5.1.7)
        assert IntegerCache.high >= 127;
    }

    private IntegerCache() {}
        
    public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
}
```
```java
总结：
    1、无论如何，Integer与new Integer不会相等。因为它们存放内存的位置不一样。在缓存范围的时候是缓存中的值和内存中开辟的新对像的比较，不在缓存范围的时候，是开辟的2个内存空间的对象的地址的比较。都不会相等。
    2、两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false。
    3、两个都是new出来的,则为false。
    4、int和integer(new或非new)比较，都为true，因为会把Integer自动拆箱为int，其实就是相当于两个int类型比较。
```
在包装类中，缓存的基本数据类型值的范围如下：
包装类型 | 基本数据类型| 缓存范围
---|---|---
Boolean | boolean | true,false
Byte | byte | -128~127
Short | short | -128~127
Character | char | 0~127
Integer | int | -128~127
Long | long | -128~127
Float | float | 无
Double | double | 无

## 27、运行结果
```java
public class Test {

	public static void main(String[] args) {
		Base b1 = new Base();
		Base b2 = new Sub();
	}
}
class Base{
	Base(){
		method(100);
	}
	public void method(int i){
		System.out.println("base : " + i);
	}
}
class Sub extends Base{
	Sub(){
		super.method(70);
	}
	public void method(int j){
		System.out.println("sub : " + j);
	}
}

```

```java
答案：
    base : 100
    sub : 100
    base : 70

过程： 
    1、new Base(),执行Base.method(100)     输出：base : 100
    2、new Sub(),
        2.1、先执行super()
        2.2、由于多态,执行Sub.method(100)  输出：sub : 100
        2.3、执行super.method(70)          输出：base : 70
```
## 29、运行结果
```java
public static void main(String[] args) {
	Integer[] datas = {1,2,3,4,5};
	List<Integer> list = Arrays.asList(datas);
	list.add(5);
	System.out.println(list.size());
}
	
结果：
    Exception in thread "main" java.lang.UnsupportedOperationException
    	at java.util.AbstractList.add(AbstractList.java:148)
    	at java.util.AbstractList.add(AbstractList.java:108)
    	at org.xinhua.io.Test.main(Test.java:10)
	
原因：Arrays.asList(datas) 返回的是 java.util.ArrayList,该类没有重新add()方法
	     调用的是 java.util.AbstractList.add(){throw new UnsupportedOperationException();}
```

# 二、基础编程

## 10、单例模式

###  1）、懒汉式

#### 方式一：双重锁

```java
public class Singleton {
    private static volatile Singleton singleton = null;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```
#### 方式二：静态内部类（推荐）

```java
public class Singleton {

    private Singleton() {
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private static class SingletonHolder {
        private static Singleton INSTANCE = new Singleton();
    }
}
```

###  2）、饿汉式

#### 方式一

```java
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();

    private Singleton() {
    }

    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```
#### 方式二：枚举

```java
public enum Singleton {
    INSTANCE
}
```

# 三、基础简答

## 18、常见错误和异常

 #### 1)、运行时异常

```java
NullPointerException            空指针
IndexOutOfBoundsException       下标越界
ClassCastException              类型转换
NoSuchMethodException           方法找不到
NoSuchElementException          元素找不到
IllegalArgumentException        非法参数
IllegalStateException           非法状态
NumberFormatException           数字类型转换
UnsupportedOperationException   不支持的操作
ArithmeticException             数学运算
```

#### 2)、编译时异常

```java
IOException                     IO异常
FileNotFoundException           文件找不到
TimeoutException                超时
InterruptedException            中断
ClassNotFoundException          找不到Class文件
UnknownHostException            解析不了主机地址
```

#### 3)、错误

```java
StackOverflowError              栈内存溢出
OutOfMemoryError                堆内存溢出
NoClassDefFoundError            运行时找不到Class
InternalError                   网络错误
```

## 25、多线程实现方式
```java
    线程：
    1、继承Thread类
    2、实现Runnable接口
    3、实现Callable接口
    
    线程池：
    1、 Executors.newSingleThreadExecutor()
    2、 Executors.newFixedThreadPool()
    3、 Executors.newCachedThreadPool()
    4、 Executors.newCachedThreadPool()  
    
    核心方法：
    new ThreadPoolExecutor(int corePoolSize,//核心线程数                 
                           int maximumPoolSize,//最大线程数 
                           long keepAliveTime,//空闲线程存活时长
                           TimeUnit unit,//时长单位
                           BlockingQueue<Runnable> workQueue,//阻塞队列
                           ThreadFactory threadFactory,//线程工厂
                           RejectedExecutionHandler handler)//拒绝策略
                           
    注：一般线程池配合 Callable、Future使用。Future等待返回结果,获取返回值
```

# 四、较难简答

## 1、Java虚拟机中内存分为哪些区域？每个区域的作用？哪些区域是线程共享的？
```java
区域：
    JVM内存 ：程序计数器、虚拟机栈、本地方法栈、堆
    直接内存：元空间
    
作用：
    程序计数器  ：记录当前方法执行的字节码行号
    虚拟机栈    ：为每个线程提供一个栈，该线程执行每个方法时创建一个栈帧。栈帧中包括局部变量表、操作数栈、动态链接、返回地址
    本地方法栈  ：调用native方法时,给本地方法使用的栈
    堆          ：存放大部分的实例对象,是垃圾回收的主要区域
        
元空间：
    类信息、常量、静态变量、方法信息、即时编译的代码
    
线程独享：  程序计数器、虚拟机栈、本地方法栈
    
线程共享：  堆、元空间
```

## 3、重写equals和hashCode方法注意事项
```java
Object类中的equals方法，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。 

在重写equals方法时，要注意满足离散数学上的特性
（1）自反性：对任意引用值x，x.equals(x)的返回值一定为true.
（2）对称性：对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true;
（3）传递性：如果x.equals(y)=true, y.equals(z)=true,则x.equals(z)=true
（4）一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变
（5）非空性：任何非空的引用值x，x.equals(null)的返回值一定为false

注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明
（1）相等对象必须具有相等的哈希码，
（2）两个对象的哈希码不相等，那么equals一定不相等。
（3）两个对象的哈希码相等，那么equals结果可能相等也可能不相等

```

## 5、HashMap的底层实现及扩容机制
```java
HashMap在JDK1.8之前：底层实现是数组+链表，扩容机制是当table中元素的个数已经达到阈值（table.length*0.75）时扩容。
（1）先计算key的hashCode值
（2）根据key的hashCode值再与数组table的长度做一个运算（%或&)，得到一个索引位置index，决定它在table那个元素（桶）下面。
（3）如果table[index]是空的，把映射关系构建为一个Entry（Entry是实现了Map.Entry类型）的对象，直接放进去
（4）如果table[index]不是空的，判断table[index]的元素的key与我们新的key调用equals方法是否相等，如果相等，替换
（5）如果table[index]不是空的，判断table[index]的元素的key与我们新的key调用equals方法全部都不相等，
    判断是否table中元素的个数已经达到阈值（table.length*0.75），
    如果已经达到，先扩容，回到（2）
    否则就构建一个Entry的对象，连接到链表的上面。

HashMap在JDK1.8之后：底层实现是数组+链表/红黑树，扩容机制
（1）先计算key的hashCode值
（2）根据key的hashCode值再与数组table的长度做一个&运算，得到一个索引位置index，决定它在table那个元素（桶）下面。
（3）如果table[index]是空的，把映射关系构建为一个Node（Node是实现了Map.Entry类型）的对象，直接放进去
（4）如果table[index]不是空的，判断table[index]的元素的key与我们新的key调用equals方法是否相等，如果相等，就用新的value替换旧的value；
	如果都不相等，再继续看
	A：如果table[index]下面已经是一棵红黑树，那么直接把映射关系构建为一个TreeNode（TreeNode是Node的子类）的对象，放到某个叶子节点上
	B：如果table[index]下面不是一棵红黑树，那么就又要判断它下面的链表的元素个数是否达到8个：
	如果没有到达8个，那么直接把映射关系构建为Node的对象，直接连接到链表的下面。
	如果已经达到8个，那么就再次判断table.length是否达到64，
	如果没有达到64，先扩容，回到（2）。
	如果已经达到64，就把该链表变成一颗红黑树，然后把新的映射关系构建一个TreeNode对象，放到某个叶子节点上。
（5）如果添加后size达到阈值（table.length*0.75），要扩容重写调整所有元素的位置。

```

# 五、较难编程

## 7、有n步台阶，一次只能上1步或2步，共有多少种走法？
```java
public static long f(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    long step1 = 1;
    long step2 = 2;
    long step3 = 0;
    for (int i = 3; i <= n; i++) {
        step3 = step1 + step2;
        step1 = step2;
        step2 = step3;
    }
    return step3;
}
```

## 11、二分查找
```java
public static int binarySearch(char[] arr, char c) {
    int left = 0;
    int right = arr.length - 1;
    int middle = 0;

    while (left <= right) {
        middle = (left + right) / 2;

        if (arr[middle] == c) {
            return middle;
        }
        if (arr[middle] > c) {
            right = middle - 1;
        } else {
            left = middle + 1;
        }
    }
    return -1;
}
```
## 13、生产者、消费者
```java
public class Test {

    public static void main(String[] args) throws Exception {
        HouseWare h = new HouseWare();
        new Thread(new Producer(h), "Producer1").start();
        new Thread(new Producer(h), "Producer2").start();
        new Thread(new Consumer(h), "Consumer1").start();
        new Thread(new Consumer(h), "Consumer2").start();
    }
}

class HouseWare {
    private final int MAX_SIZE = 10;
    private int size = 0;
    private Object[] datas = new Object[MAX_SIZE];

    public synchronized void put(Object data) {
        while (size == MAX_SIZE) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        if (size > 0) {
            for (int i = size; i > 0; i--) {
                datas[i] = datas[i - 1];
            }
        }
        datas[0] = data;
        size++;
        System.out.println(Thread.currentThread().getName() + " put  : " + data + " datas: " + dataString());
        this.notifyAll();
    }

    public synchronized Object take() {
        while (size == 0) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        Object data = datas[size - 1];
        datas[size - 1] = null;
        size--;
        System.out.println(Thread.currentThread().getName() + " take : " + data + " datas: " + dataString());
        notifyAll();
        return data;
    }

    private String dataString() {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        if (size > 0) {
            boolean first = true;
            for (int i = 0; i < size; i++) {
                if (first) {
                    first = false;
                } else {
                    sb.append(",");
                }
                sb.append(datas[i]);
            }
        }
        sb.append("]");
        return sb.toString();
    }
}

class Producer implements Runnable {
    private HouseWare h;

    public Producer(HouseWare h) {
        this.h = h;
    }

    public void run() {
        Random random = new Random();
        while (true) {
            int sleep = random.nextInt(100);
            try {
                Thread.sleep(sleep);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            h.put(sleep);
        }
    }
}

class Consumer implements Runnable {
    private HouseWare h;

    public Consumer(HouseWare h) {
        this.h = h;
    }

    public void run() {
        Random random = new Random();
        while (true) {
            int sleep = random.nextInt(100);
            try {
                Thread.sleep(sleep);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            Object data = h.take();
        }
    }
}

```
# 六、附加题

## 1、实现 replace
```java
示例：replace("aabbccbb", "bb", "dd");  结果：aaddccdd
注意：不能使用String及StringBuffer等类的replace等现成的替换API方法。

public static String replace(String text, String target, String replace) {
    if (text == null || text.length() == 0 || target == null || target.length() == 0 || replace == null) {
        return text;
    }

    int index = text.indexOf(target);
    if (index < 0) {
        return text;
    }

    StringBuilder sb = new StringBuilder();
    int start = 0;

    while (index > 0) {
        sb.append(text.substring(start, index));
        sb.append(replace);
        start = index + target.length();
        index = text.indexOf(target, start);
    }

    if (start < text.length() - 1) {
        sb.append(text.substring(start));
    }

    return sb.toString();
}
```

## 2、字母次数

```java
1个字符串中可能包含a-z中的多个字符，字符也可能重复，例如：String data = “aabcexmkduyruieiopxzkkkkasdfjxjdsds”;
写一个程序，对于给定一个这样的字符串求出字符串出现次数最多的那个字母以及出现的次数（若次数最多的字母有多个，则全部求出）

public static void maxCharCount(String str) {
    int length = str.length();
    int[] counts = new int[26];
    int maxCount = 0;

    for (int i = 0; i < length; i++) {
        char ch = str.charAt(i);
        counts[ch - 'a']++;
    }
        
    for (int i = 0; i < counts.length; i++) {
        if (counts[i] > maxCount) {
            maxCount = counts[i];
        }
    }

    for (int i = 0; i < counts.length; i++) {
        if (counts[i] == maxCount) {
            System.out.println("字母 " + (char) ('a' + i) + " 出现 " + maxCount + " 次");
        }
    }
}  
```

## 3、重叠月份数
```java
3、假设日期段用两个6位长度的正整数表示，例如：(201401，201406)用来表示2014年1月到2014年6月，求两个日期段的重叠月份数。
例如：输入：201401和201406，201403和201409，输出：4
解释：重叠月份：3,4,5,6月共4个月

public static int monthCount(int start1, int end1, int start2, int end2) {
    if (end1 < start2 || end2 < start1) {
        return 0;
    }
    int start = start1 > start2 ? start1 : start2;
    int end = end1 < end2 ? end1 : end2;
    int months1 = (start / 100) * 12 + start % 100;
    int months2 = (end / 100) * 12 + end % 100;

    return months2 - months1 + 1;
}
```

## 5、单链表反转

```java
比如一个链表是这样的：1->2->3->4->5，通过反转后成为5->4->3->2->1，
注：即实现单向链表类，在该类中提供一个单向链表的反转方法reverse

public class MyLinkedList<E> {
    private int size;
    private Node<E> first;
    private Node<E> last;

    static class Node<E> {
        E e;
        Node next;
        public Node() {}
    }

    public int size() {
        return size;
    }

    public void add(E e) {
        Node node = new Node();
        node.e = e;
        if (first == null) {
            first = last = node;
        } else {
            last.next = node;
            last = node;
        }
        size++;
    }

    public void reverse() {
        if (first == null || first.next == null) {
            return;
        }
        Node<E> node1 = first;
        Node<E> node2 = first.next;
        Node<E> node3 = null;

        Node<E> newLast = first;

        while (node2 != null) {
            node3 = node2.next;
            node2.next = node1;
            node1 = node2;
            node2 = node3;
        }

        first = node1;
        last = newLast;
        last.next = null;
    }
}
```

## 6、数组两侧元素加和相等

```java
找出数组中一个值，使其左侧值的加和等于右侧值的加和，例如：1,2,5,3,2,4,2，结果为：第4个值

public static int fn(int[] arr) {
    int index = -1;
    int leftSum = 0;
    int rightSum = 0;

    for (int i = 0; i < arr.length; i++) {
        rightSum += arr[i];
    }

    for (int i = 0; i < arr.length; i++) {
        rightSum -= arr[i];
        if (leftSum == rightSum) {
            index = i;
            break;
        }
        leftSum += arr[i];
    }

    return -1;
}
```

## 7、阻塞队列
```java
编程实现：线程A向队列Q中不停写入数据，线程B从队列Q中不停读取数据（只要Q中有数据）

public static void main(String[] args) {
    Q q = new Q(100);

    new Thread(new Runnable() {
        @Override
        public void run() {
            Random random = new Random();
            while (true) {
                try {
                    q.put(random.nextInt());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }, "A").start();

    new Thread(new Runnable() {
        @Override
        public void run() {
            while (true) {
                try {
                    Object take = q.take();
                    System.out.println(take);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }, "B").start();
}
    
class Q<E> {
    private byte[] lock = new byte[0];
    private Object[] elements;
    int maxSize;
    int size;
    
    public Q(int maxSize) {
        this.maxSize = maxSize;
        this.elements = new Object[maxSize];
    }
    
    public void put(E e) throws InterruptedException {
        synchronized (lock) {
            while (size == maxSize) {
                lock.wait();
            }
            for (int i = size; i > 0; i--) {
                elements[i] = elements[i - 1];
            }
            elements[0] = e;
            size++;
            lock.notifyAll();
        }
    }
    
    public E take() throws InterruptedException {
        synchronized (lock) {
            while (size == 0) {
                lock.wait();
            }
            E e = (E) elements[size - 1];
            elements[size - 1] = null;
            size--;
            lock.notifyAll();
            return e;
        }
    }
}
```